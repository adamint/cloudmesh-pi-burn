#! /usr/bin/env python
"""Cloudmesh Raspberry Pi Mass Image Burner.
Usage:
  cm-burn create --group GROUP --names HOSTS [--key KEY] --image IMAGE --ip IPS [--bootdrive BOOTDRIVE] [--rootdrive ROOTDRIVE]
  cm-burn gregor --group GROUP --names HOSTS --image IMAGE [--key=KEY]  [--ips=IPS]
  cm-burn ls
  cm-burn rm IMAGE
  cm-burn get [URL]
  cm-burn update
  cm-burn check install
  cm-burn hostname [HOSTNAME]
  cm-burn ssh [PUBLICKEY]
  cm-burn wifi SSID [PASSWD]
  cm-burn info
  cm-burn (-h | --help)
  cm-burn --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --key=KEY     the path of the public key [default: ~/.ssh/id_rsa.pub].
  --ips=IPS     th ips in hostlist format

Files:
  This is not fully thought through and needs to be documented
  ~/.cloudmesh/images
  ~/.cloudmesh/inventory
  Location where the images will be stored for reuse

BUG:
  bootdrive and rootdrive will be removed in a future release as they are self discoverable

Description:
  cm-burn create --names HOSTS [--key KEY] --image IMAGE --bootdrive BOOTDRIVE --rootdrive ROOTDRIVE --ssid SSID --psk PSK --ips IPS
  cm-burn update
        updates the downloaded images if new once are available
  cm-burn ls
        lists the downloaded images
  cm-burn rm IMAGE
        remove the image
  cm-burn get URL
        downloads the image at the given URL
  cm-burn get jessie
        abbreviation to download a specific version of an image.
        Identify what would be useful.
  cm-burn hostname HOSTNAME
        writes the HOSTNAME as hostname on the currently inserted SD Card
  cm-burn hostname
        reads the hostname form the curredn SD card

        Identify what woudl be useful.
Example:
  cm-burn create --names red[000-010] --key idrsa.pub --image rasbian_latest
"""
import os
import subprocess
from docopt import docopt
import hostlist
from prompter import yesno
import platform
import wget
import pathlib
from os import path
import glob
import shutil
import requests
import zipfile
import sys
from pprint import pprint
import yaml
import textwrap
import getpass
import time
import datetime

VERSION = "0.1"
debug = False

columns, lines = os.get_terminal_size()

# TODO: the dirs are only needed for windows as they are implemented now in self.filename for OSX
# we shoudl remove them and make sure that cloudmesh images gets created on osx
# and linux if it does not exist
IMAGE_DIR=os.path.expanduser("~/.cloudmesh/images")
BOOT_DIR =''

def print_function_name(func):
    """
    decorator for printing the name of the function

    :param func: the function name
    :return: the function
    """
    def echo_func(*func_args, **func_kwargs):
        print('')
        print(columns * '-')
        print('Executing {}'.format(func.__name__))
        print(columns * '-')
        return func(*func_args, **func_kwargs)

    return echo_func


def run(command):
    return subprocess.run(command, stdout=subprocess.PIPE).stdout.decode('utf-8')

def cat(path):
    with open(path, 'r') as file:
        content = file.read()
    return content

def execute(commands):
    """
       execute the commands that are included in the \n separated string line by line
       :param commands: the commands
       :return:
    """
    lines = commands.split("\n")
    for line in lines:
        print(line)
        proc = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        while proc.poll() is None:
            print(proc.stdout.readline())  # give output from your execution/your own message
        # self.commandResult = proc.wait() #catch return code


class piburner(object):

    def disable_password(self):
        """
        disables and replaces the password with a random string so that by accident the pi can not be logged into.
        The only way to login is via the ssh key
        :return:
        """
        raise NotImplementedError()

    def unmount(self):
        """
        unmounts the filesystem regardles of OS using the given path
        :param path:
        :return:
        """
        if platform.system() == 'Windows':
            #Remove drive in windows
            script = """RemoveDrive {drive}:""".format(drive = self.root_drive)
            execute(script)
        else :            
            raise NotImplementedError()

    def mount(self, device, path):
        """
        mounts the device to the filesystem regardles of OS using the given path
        :param path:
        :return:
        """
        raise NotImplementedError()

    # ok osx
    def activate_ssh(self, public_key):
        """
        sets the public key path and copies the it to the SD card
        :param public_key: the public key location
        :return: True if successful
        """

        # set the keypath
        self.keypath = public_key
        if debug:
            print(self.keypath)
        if not os.path.isfile(self.keypath):
            print("ERROR: key does not exist", self.keypath)
            sys.exit()


        # activate ssh by creating an empty ssh file in the boot drive
        Path(self.filename("/ssh")).touch()
        # Write the content of the ssh rsa to the authorized_keys file
        key = pathlib.Path(public_key).read_text()
        ssh_dir = self.filename("/home/pi/.ssh")
        print (ssh_dir)
        if not os.path.isdir(ssh_dir):
            os.makedirs(ssh_dir)
        pathlib.Path(self.filename("/home/pi/.ssh/authorized_keys")).write_text(key)

    # ok osx
    def info(self):
        if sys.platform == 'darwin':
            information = {
                "os": sys.platform,
                "ssh": os.path.exists(self.filename("/ssh")),
                "key": cat(self.filename("/home/pi/.ssh/authorized_keys")),
                "hostname": cat(self.filename("/etc/hostname"))
            }

            # print(yaml.dump(information, default_flow_style=False))
            pprint(information)


    # ok osx
    def write_hostname(self, host):
        """
        set the hostname

        :param host: the hostname
        :return:
        """
        self.host = host
        path = self.filename("/etc/hostname")
        if debug:
            print(self.host)
        pathlib.Path(path).write_text(host)

    def filename(self, path):
        """
        creates the proper path for the file bby using the proper file stsyem prefix. This method is
        supposed to universilly work, so that we simply can use the filesystem name without worying
        about the location of the root file system.

        :param path:
        :return:
        """        
        print(path)
        if platform.system() == "darwin":
            if path in ["/etc/hostname",
                        "/home/pi/.ssh/authorized_keys",
                        "/home/pi/.ssh",
                        "/etc/wpa_supplicant/wpa_supplicant.conf",
                        "/etc/dhcpcd.conf"]:
                volume = "/Volumes/rootfs"
            elif path in ["/ssh"]:
                volume = "/Volumes/boot"
            else:
                print("ERROR: path not defined in cm-burn", path)
            location = pathlib.Path("{volume}/{path}".format(volume=volume, path=path))
        elif platform.system() == "Windows":
            if path in ["/etc/hostname",
                        "/home/pi/.ssh/authorized_keys",
                        "/home/pi/.ssh",
                        "/etc/wpa_supplicant/wpa_supplicant.conf",
                        "/etc/dhcpcd.conf"]:
                volume = self.root_drive                
            elif path in ["/ssh"]:
                volume = self.boot_drive
            else:
                print("ERROR: path not defined in cm-burn", path)                
            location = pathlib.Path("{volume}:{path}".format(volume=volume, path=path))

        return location

    # ok osx
    def read_hostname(self):
        """
        set the hostname

        :param host: the hostname
        :return:
        """
        host = cat(self.filename("/etc/hostname"))
        return host


    def __init__(self):
        """
        initialize the pi burner
        TODO: provide more information
        """
        # store defaults also in ~/.cloudmesh/cm-burn.yaml as we have to execute it a lot, we can than read 
        # defaults from tehre if the file exist
        #if sys.platform == "Windows":
        #    self.windows_drive = "K"
        #    self.windows_pi_drive = "L"
        #    self.root_drive = None
        #    self.boot_drive = None

        self.host = None
        self.home = pathlib.Path(path.expanduser("~"))
        self.keypath = pathlib.Path(self.home / ".ssh" / "id_rsa.pub")
        # BUG: is this not the image directory?
        # should that not also be declared globally with pathlib
        self.cloudmesh_images = pathlib.Path(self.home / ".cloudmesh" / "images")
        if debug:
            print("HOME:", self.home)
            print("KEY:", self.keypath)
            print("IMAGES DIR", self.cloudmesh_images)
        pass

    def get(self, image):
        """
        downloads the image and stores it in ~/.cloudmesh/images
        TODO: finalize the directory, create it if image already exists  doe not  not download
        :param image: The image url
        :return:
        """
        latest = "https://downloads.raspberrypi.org/raspbian_latest"
        if image is None:
            image = latest

        if debug:
            print("Image:", image)
            print("Images dir:", self.cloudmesh_images)
        if not os.path.exists(self.cloudmesh_images):
            # TODO: check if this works if path is ~/.cloudmesh/images
            os.makedirs(self.cloudmesh_images)
        if debug:
            print(image)
        os.chdir(self.cloudmesh_images)
        # find redirectionlink
        source = requests.head(image, allow_redirects=True).url
        size = requests.get(image, stream=True).headers['Content-length']
        print(source)
        print(size)
        destination = os.path.basename(source)
        if debug:
            print(image)
            print(destination)
        download = True
        if os.path.exists(destination):
            print(os.path.getsize(destination))
            print(size)
            if int(os.path.getsize(destination)) == int(size):
                print("ERROR: file already downloded")
                download = False
        if download:
            wget.download(image)

    def ls(self):
        """
        List all images in the image directory
        :return:
        """
        images_search = pathlib.Path(self.cloudmesh_images / "*")
        if debug:
            print("images search", images_search)
        images = glob.glob(str(images_search))
        print()
        print('Available images')
        print(columns * '=')
        print('\n'.join(images))
        print()

    def set_ip(self, ip):
        """
        TODO: How to set the static IP for both wifi and wired
        :param drive: the ip 
        :return:
        """
        
        self.ip = ip

    def set_root_drive(self, drive):
        """
        TODO: provide explanation
        :param drive: the drive name for windows
        :return:
        """
        # BUG: not sure what this drive is so replace abc with something meaningfull
        self.root_drive = drive

    def set_boot_drive(self, drive):
        """
        TODO: provide information
        :param drive: the drive name for windows
        :return:
        """
        # BUG: not sure what this drive is so replace efg with something meaningfull
        self.boot_drive = drive

    def image(self, imagepath):
        # set the image
        pass



 
    def device(self, devicename):
        # set the device
        pass 
    


    def configure_wifi(self, ssid, psk):
        """
        sets the wifi. ONly works for psk based wifi
        :param ssid: the ssid
        :param psk: the psk
        :return:
        """

        wifi = textwrap.dedent("""\
                ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev 
                update_config=1 
                country=US
                
                network={{
                        ssid=\"{network}\"
                        psk=\"{pwd}\"
                        key_mgmt=WPA-PSK
                }}""".format(network=ssid, pwd=psk))
        print(wifi)
        Path(self.filename("/etc/wpa_supplicant/wpa_supplicant.conf")).write_text(wifi)

    
    def create_burn_image(self, name):
        tmp = pathlib.Path(self.cloudmesh_images) / "tmp"
        if not os.path.exists(tmp):
            # TODO: check if this works if path is ~/.cloudmesh/images
            os.makedirs(tmp)
        os.chdir(tmp)
        source = "2018-06-27-raspbian-stretch.zip"  # hardcoded for now for testing
        image_zip = pathlib.Path(self.cloudmesh_images / source)
        print("copy image", image_zip)
        shutil.copy(image_zip, source)
        print("unzip image", image_zip)
        zipfile.ZipFile(source).extractall()
        img_name = source.replace("zip", "img")
        shutil.copy(img_name, name + ".img")

    '''
    def gregor(self, names, key, ssid=None, psk=None):
        global columns
        for name in hostlist.expand_hostlist(names):
            print(columns * "-")
            print(name)
            print(columns * "-")

            # self.create_burn_image(name)
            self.mount_burn_image(name + ".img")
    '''

    def staticip(self):

        #set staticip
        staticip = """eth0
static ip_address={ip}/24
static routers=192.168.0.1
static domain_name_servers=192.168.0.1

interface wlan0

static ip_address={ip}/24
static routers=10.0.0.1
static domain_name_servers=10.0.0.1
""".format(ip=self.ip)
        print(staticip)        
        p = pathlib.Path(self.filename("/etc/dhcpcd.conf"))
        
        with open(p, 'a', encoding='utf-8') as file:
            file.write(staticip)
        
        if platform.system() == 'Windows':
            fileContents = open(p,"r").read()
            f = open(p,"w", newline="\n")
            f.write(fileContents)
            f.close()

    def burn(self):
        """
        burn the image onto the SD card
        :return: True if succesfull and test passed, false otherwise
        """
        # burn image opython device
        # if not os.path.exists(IMAGE_DIR):
        # os.makedirs(IMAGE_DIR)
        # BUG: if condition is not implemented
        
        script = ""
        if platform.system() == 'Windows':
            # BUG: does not use pathlib
            # BUG: command not in path, shoudl be in ~/.cloudmesh/bin so it can easier be found,
            # BUG: shoudl it not be installed from original
            script = "{dir}\\CommandLineDiskImager\\CommandLineDiskImager.exe {dir}\\images\\2018-06-27-raspbian-stretch.img {drive}".format(
                dir=os.getcwd(), drive=self.boot_drive)            
            # also dir needs to be done in pathlib
            # diskimager = pathlib.Path(r'/CommandLineDiskImager/CommandLineDiskImager.exe')
            # script = """{dir}\\{diskimager} {dir}\\2018-04-18-raspbian-stretch.img {drive}
            # """.format(dir=os.getcwd(), drive=self.windows_drive, diskimiger=dikimiger)
        elif platform.system() in ['Linux', 'Darwin']:
            print("not yet implemented")
        print(script)
        execute(script)
        # TODO: execute test
        # if test successful: return True else: False

    # TODO: remove bootdrives from parameters as they should be selfdicoverable
    def create(self, names, key, ips, ssid=None, psk=None, bootdrive=None, rootdrive=None):
        """
        creates a repeated burn on all names specified,
        TODO: whay is sthi not part of the previous class?

        :param names: the hostnames of in hostlist format to be burned
        :param key: the public key location # TODO: should be defaulted to ~/.ssh/id_rsa.pub
        :param bootdrive: the boot drive # TODO: on linux we do not have a boot drive, so this should not be a parameter and needs to be autodiscovered
        :param rootdrive: #TODO: on linux we do not have a boot drive, so this should not be a parameter and needs to be autodiscovered
        :param ssid: # TODO: should be set to None and if its none we do not do it we actually do not need wifi, should be handled differently
        :param psk: # TODO: should be set to None and if its none we do not do it we actually do not need wifi, should be handled differently
        :return:
        """

        hosts = hostlist.expand_hostlist(names)
        iplist = hostlist.expand_hostlist(ips)
        # BUG: can we not discover the boot and rootdrive. Why do we have to set
        # it to I and G, can we not get the next free drive letter?
        # bootdrive = find_next_free_drive_letter()
        # rootdrive = find_next_free_drive_letter()
        # BUG: are the drives released after use?         
        print(bootdrive)
        print(rootdrive)
        if bootdrive:  
            self.set_boot_drive(bootdrive)
        if rootdrive:
            self.set_root_drive(rootdrive)
        for host, ip in zip(hosts, iplist):
            print("Start Time - {currenttime}".format(currenttime = datetime.datetime.now()))
            print(columns * '-')
            print("Burning", host)
            # break
            print(columns * '-')
            yesno('Please insert the card for ' + host + "(y)?")
            print("wait till its recognized")
            print("once in conformation proceed")
        
            self.burn()
            print("burn")
            #Sleep for 5 seconds to have the SD to be mounted
            time.sleep(5)
            self.set_ip(ip)
            print("Set IP - {id}".format(id=ip))
            self.write_hostname(host)
            print("Updating host - {name}".format(name=host))

            print("ssid - {id}".format(id=ssid))
            print("psk - {pwd}".format(pwd=psk))
            if ssid:
                self.configure_wifi(ssid, psk)
                print("Updating wifi")

            self.activate_ssh(key)
            print("Updating ssh")

            self.staticip()
            print("Updating Network - Static IP")  

            self.unmount()
            print("Removed drive")

            print("Please remove the card for host", host)
            yesno("Press y once the card is removed")

            print("take the card out")
            print("End Time - {currenttime}".format(currenttime = datetime.datetime.now()))
            break

def analyse():    
   # if arguments["rm"]:
   #     rm(arguments["image"])

   # elif arguments["get"]:
   #     print(arguments["URL"])
   #     get(arguments["URL"])
   # elif arguments["ls"]:
    if arguments["ls"]:
        burner = piburner()
        burner.ls()

    elif arguments["create"]:
        burner = piburner()
        burner.create(arguments["HOSTS"],
                      arguments["KEY"],
                      arguments["IPS"],
                      arguments["SSID"],
                      arguments["PSK"],
                      arguments["BOOTDRIVE"],
                      arguments["ROOTDRIVE"])

    elif arguments["check"] and arguments["install"]:
        print("ERROR: not yet implemented")

    elif arguments["hostname"]:
        host = arguments["HOSTNAME"]
        burner = piburner()

        if host != None:
            print("Set host to:", host)
            burner.write_hostname(host)
        else:
            print(burner.read_hostname())

    elif arguments["wifi"]:
        ssid = arguments["SSID"]
        passwd = arguments["PASSWD"]
        if passwd is None:
            passwd = getpass.getpass()
        print (ssid)
        print (passwd)
        burner = piburner()
        burner.configure_wifi(ssid, passwd)

    elif arguments["ssh"]:
        key = arguments["PUBLICKEY"]
        if key is None:
            key = os.path.expanduser("~") + "/.ssh/id_rsa.pub"
        print("Use ssh key:", key)
        burner = piburner()
        burner.activate_ssh(key)

    elif arguments["info"]:
        burner = piburner()
        burner.info()


if __name__ == '__main__':
    arguments = docopt(__doc__, version=VERSION)
    # if debug:
    #   print(arguments) # just for debugging
    analyse()