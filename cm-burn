#! /usr/bin/env python
"""Cloudmesh Raspberry Pi Mass Image Burner.

Usage:
  cm-burn create --group GROUP --names HOSTS [--key KEY] --image IMAGE --ip IPS --bootdrive BOOTDRIVE --rootdrive ROOTDRIVE
  cm-burn ls
  cm-burn rm IMAGE
  cm-burn get [URL]
  cm-burn update
  cm-burn (-h | --help)
  cm-burn --version
Options:
  -h --help     Show this screen.
  --version     Show version.
Files:
  This is not fully thought through and needs to be documented
  ~/.cloudmesh/images
  ~/.cloudmesh/inventory
  Location where the images will be stored for reuse
Description:
  cm-burn create --names HOSTS [--key KEY] --image IMAGE --bootdrive BOOTDRIVE --rootdrive ROOTDRIVE --ssid SSID --psk PSK
  cm-burn update
        updates the downloaded images if new once are available
  cm-burn ls
        lists the downloaded images
  cm-burn rm IMAGE
        remove the image
  cm-burn get URL
        downloads the image at the given URL
  cm-burn get jessie
        abbreviation to download a specific version of an image.
        Identify what woudl be useful.
Example:
  cm-burn create --names red[000-010] --key idrsa.pub --image rasbian_latest
"""
import os
import subprocess
from docopt import docopt
import hostlist
from prompter import yesno
import platform
import wget
from pathlib import Path
import pathlib
from os import path


VERSION = "0.1"
debug = True

columns, lines = os.get_terminal_size()

IMAGE_DIR=os.path.expanduser("images")
BOOT_DIR =''

def print_function_name(func):
    def echo_func(*func_args, **func_kwargs):
        print('')
        print(columns * '-')
        print('Executing {}'.format(func.__name__))
        print(columns * '-')
        return func(*func_args, **func_kwargs)
npm install -g reveal-md
    return echo_func

def execute(commands):
    lines = commands.split("\n")
    for line in lines:
        #os.system(line)
        print(line)
        proc = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        while proc.poll() is None:         
         print(proc.stdout.readline()) #give output from your execution/your own message
        #self.commandResult = proc.wait() #catch return code

@print_function_name
def get(image):
    print(image)
    if not os.path.exists(IMAGE_DIR):
        # BUG: check if this works if path is ~/.cloudmesh/images
        os.makedirs(IMAGE_DIR)
    if image is None:
        image = "https://downloads.raspberrypi.org/raspbian_latest"
    # script = """
    # cd {dir}
    #""".format(dir=os.getcwd() + '\\' + IMAGE_DIR)
    #print(script)
    os.chdir(IMAGE_DIR)
    # BUG: if image is None, it does not have image[0] its not an
    # array its just a string, you need to settle on one data
    # structure
    print(image[0])
    wget.download(image[0])


@print_function_name
def rm(image):
    # BUG: Not implemented
    print(image)

@print_function_name
def ls():
    # BUG: do this the pythonic way with glob.glob
    script = """
    ls  -1 {dir}
    """.format(dir=IMAGE_DIR)
    execute(script)

class piburner (object):

    @print_function_name
    def __init__ (self):
        # store defaults also in ~/.cloudmesh/cm-burn.yaml as we have to execute it a lot, we can than read 
        # defaults from tehre if the file exist
        self.windows_drive = "G"
        self.windows_pi_drive = "I"
        self.home = pathlib.Path(path.expanduser("~"))
        self.cloudmesh_pi = pathlib.Path(self.home / ".cloudmesh" / "pi")
        pass

    def set_root_drive(self, abc):
        # not sure what this drive is so replace abc with somethingmeaningfull
        self.root_drive = abc

    def set_boot_drive(self, efg):
        # not sure what this drive is so replace efg with somethingmeaningfull
        self.boot_drive = efg
	
    def image(self, imagepath):
        # set the image
        pass
 
    def device(self, devicename):
        # set the device
        pass

    def burn(self):
        # burn image opython device
        #if not os.path.exists(IMAGE_DIR):
        # os.makedirs(IMAGE_DIR)
        script = """{dir}\\CommandLineDiskImager\\CommandLineDiskImager.exe {dir}\\2018-04-18-raspbian-stretch.img {drive}
        """.format(dir=os.getcwd(), drive=self.windows_drive)
        # also dir needs to be done in pathlib
        #diskimager = pathlib.Path(r'/CommandLineDiskImager/CommandLineDiskImager.exe')
        #script = """{dir}\\{diskimager} {dir}\\2018-04-18-raspbian-stretch.img {drive}
        #""".format(dir=os.getcwd(), drive=self.windows_drive, diskimiger=dikimiger)
        print(script)
        execute(script)
       
    def unmountdrive(self):
        #Remove drive in windows
        script = """RemoveDrive {drive}:""".format(drive = self.root_drive)
        execute(script)

    def hostname(self, host):
        # set the hostname 
        self.host = host        
        Path("{rootdrive}:/etc/hostname".format(rootdrive = self.root_drive)).write_text(host)
        print(self.host)
        
	
    def key(self, keypath):
        # set the keypath
        self.keypath = keypath
        print(self.keypath)   
        #enable ssh by creating a ssh file in the boot folder        
        open(Path("{bootdrive}:/".format(bootdrive = self.boot_drive)) / "ssh", 'w+')
        #Create directory .ssh
        Path("{rootdrive}:/home/pi/.ssh".format(rootdrive = self.root_drive)).mkdir(parents=True, exist_ok=True)
        #execute(script)
        #Read contents of the ssh rsa file 
        content =  Path(keypath).read_text()
        
        #Write the content of the ssh rsa to the authorized_keys file
        Path("{rootdrive}:/home/pi/.ssh/authorized_keys".format(rootdrive = self.root_drive)).write_text(content)
        
        
    def wifi(self,ssid,psk):
        #set wifi
        wifi = """ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev 
update_config=1 
country=US

network={{
        ssid=\"{network}\"
        psk=\"{pwd}\"
        key_mgmt=WPA-PSK
}}""".format(network=ssid,pwd=psk)
        print(wifi)        
        Path("{rootdrive}:/etc/wpa_supplicant/wpa_supplicant.conf".format(rootdrive = self.root_drive)).write_text(wifi)        
    
    def ip(self, ipaddress):
        # set ip
        pass


@print_function_name
def create(names, key, bootdrive, rootdrive, ssid, psk):   
    hosts = hostlist.expand_hostlist(names)    
    burner = piburner()   
    burner.set_boot_drive(bootdrive)
    burner.set_root_drive(rootdrive)
    for host in hosts:
        print(columns * '-')
        print ("Burning", host)
        #break
        print(columns * '-')
        yesno('Please insert the card for ' + host + "(y)?")
        print("wait till its recognized")
        print("once in conformation proceed")
        
        burner.burn()
        print("burn")        
        
        burner.hostname(host)
        print("Updating host")  
        
        print("ssid - {id}".format(id=ssid))
        print("psk - {pwd}".format(pwd=psk))
        burner.wifi(ssid, psk)
        print("Updating wifi")  
        
        burner.key(key)
        print("Updating ssh")
        
        burner.unmountdrive()
        print("Removed drive")
        print("Please remove the card for host", host)
        yesno("Press y once the card is removed")

        print("take the card out")
        break
   
    
    
    
def analyse():    
    if arguments["rm"]:
        rm(arguments["image"])
    elif arguments["get"]:
        print(arguments["URL"])
        get(arguments["URL"])
    elif arguments["ls"]:
        ls()
    elif arguments["rm"]:
        rm(arguments["IMAGE"])
    elif arguments["create"]:
        create(arguments["HOSTS"], arguments["KEY"], arguments["BOOTDRIVE"],arguments["ROOTDRIVE"], arguments["SSID"], arguments["PSK"])
if __name__ == '__main__':
    arguments = docopt(__doc__, version=VERSION)
    print('test')
    #if debug:
    #   print(arguments) # just for debugging
    analyse()
