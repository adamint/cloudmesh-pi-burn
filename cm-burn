#! /usr/bin/env python
"""Cloudmesh Raspberry Pi Mass Image Burner.

Usage:
  cm-burn create --group GROUP --names HOSTS [--key KEY] --image IMAGE --ip IPS --bootdrive BOOTDRIVE --rootdrive ROOTDRIVE
  cm-burn ls
  cm-burn rm IMAGE
  cm-burn get [URL]
  cm-burn update
  cm-burn (-h | --help)
  cm-burn --version
Options:
  -h --help     Show this screen.
  --version     Show version.
Files:
  This is not fully thought through and needs to be documented
  ~/.cloudmesh/images
  ~/.cloudmesh/inventory
  Location where the images will be stored for reuse
Description:
  cm-burn create --names HOSTS [--key KEY] --image IMAGE --bootdrive BOOTDRIVE --rootdrive ROOTDRIVE --ssid SSID --psk PSK
  cm-burn update
        updates the downloaded images if new once are available
  cm-burn ls
        lists the downloaded images
  cm-burn rm IMAGE
        remove the image
  cm-burn get URL
        downloads the image at the given URL
  cm-burn get jessie
        abbreviation to download a specific version of an image.
        Identify what would be useful.
Example:
  cm-burn create --names red[000-010] --key idrsa.pub --image rasbian_latest
"""
import os
import subprocess
from docopt import docopt
import hostlist
from prompter import yesno
import platform
import wget
from pathlib import Path
import pathlib
from os import path
import glob

VERSION = "0.1"
debug = True

columns, lines = os.get_terminal_size()

IMAGE_DIR = os.path.expanduser("images")
BOOT_DIR = ''


def print_function_name(func):
    """
    decorator for printing the name of the function

    :param func: the function name
    :return: the function
    """

    def echo_func(*func_args, **func_kwargs):
        print('')
        print(columns * '-')
        print('Executing {}'.format(func.__name__))
        print(columns * '-')
        return func(*func_args, **func_kwargs)

    return echo_func


def execute(commands):
    """
    execute the commands that are included in the \n separated string line by line
    :param commands: the commands
    :return:
    """
    commandlines = commands.split("\n")
    for line in commandlines:
        # os.system(line)
        print(line)
        proc = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        while proc.poll() is None:
            print(proc.stdout.readline())  # give output from your execution/your own message
        # self.commandResult = proc.wait() #catch return code


def get(image):
    """
    downloads the image and stores it in ~/.cloudmesh/images
    TODO: finalize the directory, create it if image already exists  doe not  not download
    :param image: The image url
    :return:
    """
    print(image)
    if not os.path.exists(IMAGE_DIR):
        # TODO: check if this works if path is ~/.cloudmesh/images
        os.makedirs(IMAGE_DIR)
    if image is None:
        image = "https://downloads.raspberrypi.org/raspbian_latest"
    # script = """
    # cd {dir}
    # """.format(dir=os.getcwd() + '\\' + IMAGE_DIR)
    # print(script)
    os.chdir(IMAGE_DIR)
    # TODO: if image is None, it does not have image[0] its not an
    # array its just a string, you need to settle on one data
    # structure
    print(image[0])
    wget.download(image[0])


class piburner(object):

    def __init__(self):
        """
        initialize the pi burner
        TODO: provide more information
        """
        # store defaults also in ~/.cloudmesh/cm-burn.yaml as we have to execute it a lot, we can than read 
        # defaults from tehre if the file exist
        self.windows_drive = "G"
        self.windows_pi_drive = "I"
        self.root_drive = None
        self.boot_drive = None
        self.host = None
        self.home = pathlib.Path(path.expanduser("~"))
        self.keypath = pathlib.Path(self.home / ".ssh" / "id_rsa.pub")
        # BUG: is this not the image directory?
        # should that not also be declared globally with pathlib
        self.cloudmesh_images = pathlib.Path(self.home / ".cloudmesh" / "images")
        if debug:
            print("HOME:", self.home)
            print("KEY:", self.keypath)
            print("IMAGES DIR", self.cloudmesh_images)
        pass

    def ls(self):
        """
        List all images in the image directory
        :return:
        """
        # TODO: do this the pythonic way with glob.glob
        images_search = pathlib.Path(self.cloudmesh_images / "*")
        if debug:
            print ("images search", images_search)
        images = glob.glob(str(images_search))
        print ()
        print ('Available images')
        print (columns * '=')
        print ('\n'.join(images))
        print ()

    def set_root_drive(self, abc):
        """
        TODO: provide explanation
        :param abc: TODO: not a good name
        :return:
        """
        # BUG: not sure what this drive is so replace abc with something meaningfull
        self.root_drive = abc

    def set_boot_drive(self, efg):
        """
        TODO: provide information
        :param efg: TODO: not a good name
        :return:
        """
        # BUG: not sure what this drive is so replace efg with something meaningfull
        self.boot_drive = efg

    def image(self, imagepath):
        """
        set the default image
        :param imagepath: the default image path into the image directory
        :return:
        """
        # set the image
        BUG: not implemented
        pass

    def device(self, devicename):
        """
        The default device name for ???
        :param devicename: the device name
        :return:
        """
        # set the device
        BUG: not implemented
        pass

    def burn(self):
        """
        burn the image onto the SD card
        :return: True if succesfull and test passed, false otherwise
        """
        # burn image opython device
        # if not os.path.exists(IMAGE_DIR):
        # os.makedirs(IMAGE_DIR)
        # BUG: if condition is not implemented
        script = ""
        if platform.system() == 'Windows':
            # BUG: does not use pathlib
            script = "{dir}\\CommandLineDiskImager\\CommandLineDiskImager.exe {dir}\\2018-04-18-raspbian-stretch.img {drive}".format(
                dir=os.getcwd(), drive=self.windows_drive)
        # also dir needs to be done in pathlib
        # diskimager = pathlib.Path(r'/CommandLineDiskImager/CommandLineDiskImager.exe')
        # script = """{dir}\\{diskimager} {dir}\\2018-04-18-raspbian-stretch.img {drive}
        # """.format(dir=os.getcwd(), drive=self.windows_drive, diskimiger=dikimiger)
        elif platform.system() in ['Linux', 'Darwin']:
            print("not yet implemented")
        print(script)
        execute(script)
        # TODO: execute test
        # if test successful: return True else: False

    def unmountdrive(self):
        """
        Remove drive in windows
        :return: True is successful
        """
        #
        script = """RemoveDrive {drive}:""".format(drive=self.root_drive)
        execute(script)
        # if test successful: return True else: False

    def hostname(self, host):
        """
        set the hostname

        :param host: the hostname
        :return:
        """
        self.host = host
        # does this work?
        Path("{rootdrive}:/etc/hostname".format(rootdrive=self.root_drive)).write_text(host)
        print(self.host)

    def key(self, public_key):
        """
        sets the public key path and copies the it to the SD card
        :param public_key: the public key location
        :return: True if successful
        """

        # set the keypath
        self.keypath = public_key
        print(self.keypath)
        # BUG: if condition needs to be used as boot drive not properly defined for linux/osx
        # enable ssh by creating a ssh file in the boot folder
        open(Path("{bootdrive}:/".format(bootdrive=self.boot_drive)) / "ssh", 'w+')
        # Create directory .ssh
        Path("{rootdrive}:/home/pi/.ssh".format(rootdrive=self.root_drive)).mkdir(parents=True, exist_ok=True)
        # execute(script)
        # Read contents of the ssh rsa file
        content = Path(public_key).read_text()

        # Write the content of the ssh rsa to the authorized_keys file
        Path("{rootdrive}:/home/pi/.ssh/authorized_keys".format(rootdrive=self.root_drive)).write_text(content)
        # if test successful: return True else: False

    def wifi(self, ssid, psk):
        """
        sets the wifi. ONly works for psk based wifi
        :param ssid: the ssid
        :param psk: the psk
        :return:
        """

        # TODO: use textdedent so its easier to read and script can be indented.
        wifi = """\
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev 
update_config=1 
country=US

network={{
        ssid=\"{network}\"
        psk=\"{pwd}\"
        key_mgmt=WPA-PSK
}}""".format(network=ssid, pwd=psk)
        print(wifi)
        Path("{rootdrive}:/etc/wpa_supplicant/wpa_supplicant.conf".format(rootdrive=self.root_drive)).write_text(wifi)

    def ip(self, ipaddress):
        # Bug: not implemented
        # set ip
        pass


def create(names, key, bootdrive, rootdrive, ssid=None, psk=None):
    """
    creates a repeated burn on all names specified,
    TODO: whay is sthi not part of the previous class?

    :param names: the hostnames of in hostlist format to be burned
    :param key: the public key location # TODO: should be defaulted to ~/.ssh/id_rsa.pub
    :param bootdrive: the boot drive # TODO: on linux we do not have a boot drive, so this should not be a parameter and needs to be autodiscovered
    :param rootdrive: #TODO: on linux we do not have a boot drive, so this should not be a parameter and needs to be autodiscovered
    :param ssid: # TODO: should be set to None and if its none we do not do it we actually do not need wifi, should be handled differently
    :param psk: # TODO: should be set to None and if its none we do not do it we actually do not need wifi, should be handled differently
    :return:
    """

    hosts = hostlist.expand_hostlist(names)
    burner = piburner()
    # BUG: can we not discover the boot and rootdrive. Why do we have to set
    # it to I and G, can we not get the next free drive letter?
    # bootdrive = find_next_free_drive_letter()
    # rootdrive = find_next_free_drive_letter()
    # BUG: are the drives released after use?
    burner.set_boot_drive(bootdrive)
    burner.set_root_drive(rootdrive)
    for host in hosts:
        print(columns * '-')
        print("Burning", host)
        # break
        print(columns * '-')
        yesno('Please insert the card for ' + host + "(y)?")
        print("wait till its recognized")
        print("once in conformation proceed")

        burner.burn()
        print("burn")

        burner.hostname(host)
        print("Updating host")

        print("ssid - {id}".format(id=ssid))
        print("psk - {pwd}".format(pwd=psk))
        if ssid:
            burner.wifi(ssid, psk)
        print("Updating wifi")

        burner.key(key)
        print("Updating ssh")

        burner.unmountdrive()
        print("Removed drive")
        print("Please remove the card for host", host)
        yesno("Press y once the card is removed")

        print("take the card out")
        break


def analyse():
    if arguments["rm"]:
        rm(arguments["image"])
    elif arguments["get"]:
        print(arguments["URL"])
        get(arguments["URL"])
    elif arguments["ls"]:
        burner = piburner()
        burner.ls()
    elif arguments["rm"]:
        rm(arguments["IMAGE"])
    elif arguments["create"]:
        create(arguments["HOSTS"], arguments["KEY"], arguments["BOOTDRIVE"], arguments["ROOTDRIVE"], arguments["SSID"],
               arguments["PSK"])


if __name__ == '__main__':
    arguments = docopt(__doc__, version=VERSION)
    print('test')
    # if debug:
    #   print(arguments) # just for debugging
    analyse()
