#! /usr/bin/env python
"""Cloudmesh Raspberry Pi Mass Image Burner.

Usage:
  cm-burn create --group GROUP --names HOSTS --image IMAGE [--key=KEY]  [--ips=IPS]
  cm-burn gregor --group GROUP --names HOSTS --image IMAGE [--key=KEY]  [--ips=IPS]
  cm-burn ls
  cm-burn rm IMAGE
  cm-burn get [URL]
  cm-burn update
  cm-burn check install
  cm-burn hostname [HOSTNAME]
  cm-burn ssh [PUBLICKEY]
  cm-burn info
  cm-burn (-h | --help)
  cm-burn --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --key=KEY     the path of the public key [default: ~/.ssh/id_rsa.pub].
  --ips=IPS     th ips in hostlist format

Files:
  This is not fully thought through and needs to be documented
  ~/.cloudmesh/images
  ~/.cloudmesh/inventory
  Location where the images will be stored for reuse

Description:
  cm-burn create --names HOSTS [--key KEY] --image IMAGE --bootdrive BOOTDRIVE --rootdrive ROOTDRIVE --ssid SSID --psk PSK
  cm-burn update
        updates the downloaded images if new once are available
  cm-burn ls
        lists the downloaded images
  cm-burn rm IMAGE
        remove the image
  cm-burn get URL
        downloads the image at the given URL
  cm-burn get jessie
        abbreviation to download a specific version of an image.
        Identify what would be useful.
  cm-burn hostname HOSTNAME
        writes the HOSTNAME as hostname on the currently inserted SD Card
  cm-burn hostname
        reads the hostname form the curredn SD card

Example:
  cm-burn create --names red[000-010] ips --image rasbian_latest

"""
import os
import subprocess
from docopt import docopt
import hostlist
from prompter import yesno
import platform
import wget
from pathlib import Path
import pathlib
from os import path
import glob
import shutil
import progressbar
import requests
import zipfile
import sys
from pprint import pprint
import yaml
import textwrap

VERSION = "0.1"
debug = True

columns, lines = os.get_terminal_size()

IMAGE_DIR = os.path.expanduser("images")
BOOT_DIR = ''


def print_function_name(func):
    """
    decorator for printing the name of the function

    :param func: the function name
    :return: the function
    """

    def echo_func(*func_args, **func_kwargs):
        print('')
        print(columns * '-')
        print('Executing {}'.format(func.__name__))
        print(columns * '-')
        return func(*func_args, **func_kwargs)

    return echo_func


def run(command):
    return subprocess.run(command, stdout=subprocess.PIPE).stdout.decode('utf-8')

def cat(path):
    with open(path, 'r') as file:
        content = file.read()
    return content

def execute(commands):
    """
    execute the commands that are included in the \n separated string line by line
    :param commands: the commands
    :return:
    """
    commandlines = commands.split("\n")
    for line in commandlines:
        # os.system(line)
        print(line)
        proc = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        while proc.poll() is None:
            print(proc.stdout.readline())  # give output from your execution/your own message
        # self.commandResult = proc.wait() #catch return code


class piburner(object):

    def disable_password(self):
        """
        disables and replaces the password with a random string so that by accident the pi can not be logged into.
        The only way to login is via the ssh key
        :return:
        """
        raise NotImplementedError()

    def add_public_key(self):
        """
        adds the public key to the authorized host name
        :return:
        """

    def unmount(self, path):
        """
        unmounts the filesystem regardles of OS using the given path
        :param path:
        :return:
        """
        raise NotImplementedError()

    def mount(self, device, path):
        """
        mounts the device to the filesystem regardles of OS using the given path
        :param path:
        :return:
        """
        raise NotImplementedError()

    # ok osx
    def activate_ssh(self, public_key):
        """
        sets the public key path and copies the it to the SD card
        :param public_key: the public key location
        :return: True if successful
        """

        # set the keypath
        self.keypath = public_key
        if debug:
            print(self.keypath)
        if not os.path.isfile(self.keypath):
            print("ERROR: key does not exist", self.keypath)
            sys.exit()


        # activate ssh by creating an empty ssh file in the boot drive
        Path(self.filename("/ssh")).touch()
        # Write the content of the ssh rsa to the authorized_keys file
        key = Path(public_key).read_text()
        os.makedirs(self.filename("/home/pi/.ssh"))
        Path(self.filename("/home/pi/.ssh/authorized_keys")).write_text(key)

    # ok osx
    def info(self):
        if sys.platform == 'darwin':
            information = {
                "os": sys.platform,
                "ssh": os.path.exists(self.filename("/ssh")),
                "key": cat(self.filename("/home/pi/.ssh/authorized_keys")),
                "hostname": cat(self.filename("/etc/hostname"))
            }

            # print(yaml.dump(information, default_flow_style=False))
            pprint(information)


    # ok osx
    def write_hostname(self, host):
        """
        set the hostname

        :param host: the hostname
        :return:
        """
        self.host = host
        path = self.filename("/etc/hostname")
        if debug:
            print(self.host)
        Path(path).write_text(host)

    def filename(self, path):
        """
        creates the proper path for the file bby using the proper file stsyem prefix. This method is
        supposed to universilly work, so that we simply can use the filesystem name without worying
        about the location of the root file system.

        :param path:
        :return:
        """

        if sys.platform == "darwin":
            if path in ["/etc/hostname",
                        "/home/pi/.ssh/authorized_keys",
                        "/home/pi/.ssh",
                        "/etc/wpa_supplicant/wpa_supplicant.conf"]:
                volume = "/Volumes/rootfs"
            elif path in ["/ssh"]:
                volume = "/Volumes/boot"
            else:
                print("ERROR: path not defined in cm-burn", path)
            location = Path("{volume}/{path}".format(volume=volume, path=path))
        elif sys.platform == "Windows":
            if path in ["etc/hostname"]:
                volume = "TBD"
                raise NotImplementedError()
            if path in ["ssh"]:
                volume = "TBD"
                raise NotImplementedError()
            location = Path("{volume}:{path}".format(volume=volume, path=path))

        return location

    # ok osx
    def read_hostname(self):
        """
        set the hostname

        :param host: the hostname
        :return:
        """
        host = cat(self.filename("/etc/hostname"))
        return self.host


    def __init__(self):
        """
        initialize the pi burner
        TODO: provide more information
        """
        # store defaults also in ~/.cloudmesh/cm-burn.yaml as we have to execute it a lot, we can than read 
        # defaults from tehre if the file exist
        if sys.platform == "Windows":
            self.windows_drive = "K"
            self.windows_pi_drive = "L"
            self.root_drive = None
            self.boot_drive = None

        self.host = None
        self.home = pathlib.Path(path.expanduser("~"))
        self.keypath = pathlib.Path(self.home / ".ssh" / "id_rsa.pub")
        # BUG: is this not the image directory?
        # should that not also be declared globally with pathlib
        self.cloudmesh_images = pathlib.Path(self.home / ".cloudmesh" / "images")
        if debug:
            print("HOME:", self.home)
            print("KEY:", self.keypath)
            print("IMAGES DIR", self.cloudmesh_images)
        pass

    def get(self, image):
        """
        downloads the image and stores it in ~/.cloudmesh/images
        TODO: finalize the directory, create it if image already exists  doe not  not download
        :param image: The image url
        :return:
        """
        latest = "https://downloads.raspberrypi.org/raspbian_latest"
        if image is None:
            image = latest

        if debug:
            print("Image:", image)
            print("Images dir:", self.cloudmesh_images)
        if not os.path.exists(self.cloudmesh_images):
            # TODO: check if this works if path is ~/.cloudmesh/images
            os.makedirs(self.cloudmesh_images)
        if debug:
            print(image)
        os.chdir(self.cloudmesh_images)
        # find redirectionlink
        source = requests.head(image, allow_redirects=True).url
        size = requests.get(image, stream=True).headers['Content-length']
        print(source)
        print(size)
        destination = os.path.basename(source)
        if debug:
            print(image)
            print(destination)
        download = True
        if os.path.exists(destination):
            print(os.path.getsize(destination))
            print(size)
            if int(os.path.getsize(destination)) == int(size):
                print("ERROR: file already downloded")
                download = False
        if download:
            wget.download(image)

    def ls(self):
        """
        List all images in the image directory
        :return:
        """
        images_search = pathlib.Path(self.cloudmesh_images / "*")
        if debug:
            print("images search", images_search)
        images = glob.glob(str(images_search))
        print()
        print('Available images')
        print(columns * '=')
        print('\n'.join(images))
        print()

    def set_root_drive(self, drive):
        """
        TODO: provide explanation
        :param drive: the drive name for windows
        :return:
        """
        # BUG: not sure what this drive is so replace abc with something meaningfull
        self.root_drive = drive

    def set_boot_drive(self, drive):
        """
        TODO: provide information
        :param drive: the drive name for windows
        :return:
        """
        # BUG: not sure what this drive is so replace efg with something meaningfull
        self.boot_drive = drive

    def image(self, imagepath):
        """
        set the default image
        :param imagepath: the default image path into the image directory
        :return:
        """
        # set the image
        BUG: not implemented
        pass



    def unmountdrive(self):
        """
        Remove drive in windows
        :return: True is successful
        """
        #
        script = """RemoveDrive {drive}:""".format(drive=self.root_drive)
        execute(script)
        # if test successful: return True else: False


    def wifi(self, ssid, psk):
        """
        sets the wifi. ONly works for psk based wifi
        :param ssid: the ssid
        :param psk: the psk
        :return:
        """

        wifi = textwrap.dedent("""\
                ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev 
                update_config=1 
                country=US
                
                network={{
                        ssid=\"{network}\"
                        psk=\"{pwd}\"
                        key_mgmt=WPA-PSK
                }}""".format(network=ssid, pwd=psk))
        print(wifi)
        Path(self.filename("/etc/wpa_supplicant/wpa_supplicant.conf").format(rootdrive=self.root_drive)).write_text(wifi)

    def ip(self, ipaddress):
        # Bug: not implemented
        # set ip
        pass

    def create_burn_image(self, name):
        tmp = pathlib.Path(self.cloudmesh_images) / "tmp"
        if not os.path.exists(tmp):
            # TODO: check if this works if path is ~/.cloudmesh/images
            os.makedirs(tmp)
        os.chdir(tmp)
        source = "2018-06-27-raspbian-stretch.zip"  # hardcoded for now for testing
        image_zip = pathlib.Path(self.cloudmesh_images / source)
        print("copy image", image_zip)
        shutil.copy(image_zip, source)
        print("unzip image", image_zip)
        zipfile.ZipFile(source).extractall()
        img_name = source.replace("zip", "img")
        shutil.copy(img_name, name + ".img")

    def gregor(self, names, key, ssid=None, psk=None):
        global columns
        for name in hostlist.expand_hostlist(names):
            print(columns * "-")
            print(name)
            print(columns * "-")

            # self.create_burn_image(name)
            self.mount_burn_image(name + ".img")



    def burn(self):
        """
        burn the image onto the SD card
        :return: True if succesfull and test passed, false otherwise
        """
        # burn image opython device
        # if not os.path.exists(IMAGE_DIR):
        # os.makedirs(IMAGE_DIR)
        # BUG: if condition is not implemented
        script = ""
        if platform.system() == 'Windows':
            # BUG: does not use pathlib
            # BUG: command not in path, shoudl be in ~/.cloudmesh/bin so it can easier be found,
            # BUG: shoudl it not be installed from original
            script = "{dir}\\CommandLineDiskImager\\CommandLineDiskImager.exe {dir}\\2018-04-18-raspbian-stretch.img {drive}".format(
                dir=os.getcwd(), drive=self.windows_drive)
            # also dir needs to be done in pathlib
            # diskimager = pathlib.Path(r'/CommandLineDiskImager/CommandLineDiskImager.exe')
            # script = """{dir}\\{diskimager} {dir}\\2018-04-18-raspbian-stretch.img {drive}
            # """.format(dir=os.getcwd(), drive=self.windows_drive, diskimiger=dikimiger)
        elif platform.system() in ['Linux', 'Darwin']:
            print("not yet implemented")
        print(script)
        execute(script)
        # TODO: execute test
        # if test successful: return True else: False

    # replace with sefl.filname logic
    def create(self, names, key, ssid=None, psk=None):
        """
        creates a repeated burn on all names specified,
        TODO: whay is sthi not part of the previous class?

        :param names: the hostnames of in hostlist format to be burned
        :param key: the public key location # TODO: should be defaulted to ~/.ssh/id_rsa.pub
        :param bootdrive: the boot drive # TODO: on linux we do not have a boot drive, so this should not be a parameter and needs to be autodiscovered
        :param rootdrive: #TODO: on linux we do not have a boot drive, so this should not be a parameter and needs to be autodiscovered
        :param ssid: # TODO: should be set to None and if its none we do not do it we actually do not need wifi, should be handled differently
        :param psk: # TODO: should be set to None and if its none we do not do it we actually do not need wifi, should be handled differently
        :return:
        """

        hosts = hostlist.expand_hostlist(names)
        # BUG: can we not discover the boot and rootdrive. Why do we have to set
        # it to I and G, can we not get the next free drive letter?
        # bootdrive = find_next_free_drive_letter()
        # rootdrive = find_next_free_drive_letter()
        # BUG: are the drives released after use?
        for host in hosts:
            print(columns * '-')
            print("Burning", host)
            # break
            print(columns * '-')
            yesno('Please insert the card for ' + host + "(y)?")
            print("wait till its recognized")
            print("once in conformation proceed")

            self.burn()
            print("burn")

            self.write_hostname(host)
            print("Updating host")

            print("ssid - {id}".format(id=ssid))
            print("psk - {pwd}".format(pwd=psk))
            if ssid:
                self.wifi(ssid, psk)
            print("Updating wifi")

            self.key(key)
            print("Updating ssh")

            if os.platform() == 'Windows':
                self.unmountdrive()
                print("Removed drive")

            print("Please remove the card for host", host)
            yesno("Press y once the card is removed")

            print("take the card out")
            break


def analyse():
    if debug:
        print(arguments)

    if arguments["rm"]:
        rm(arguments["image"])
    elif arguments["get"]:
        url = arguments["URL"]
        if url == []:
            url = None
        else:
            url = url[0]
        print(url)

        burner = piburner()
        burner.get(url)

    elif arguments["ls"]:
        burner = piburner()
        burner.ls()
    elif arguments["rm"]:
        rm(arguments["IMAGE"])
    elif arguments["create"]:
        burner = piburner()
        burner.create(arguments["HOSTS"],
                      arguments["KEY"],
                      arguments["SSID"],
                      arguments["PSK"])
    elif arguments["gregor"]:

        burner = piburner()

        burner.gregor(
            arguments["HOSTS"],
            arguments["--key"]
        )
    elif arguments["check"] and arguments["install"]:
        print("ERROR: not yet implemented")
    elif arguments["hostname"]:
        host = arguments["HOSTNAME"]
        print("set host to", host)
        burner = piburner()

        if host != None:
            burner.write_hostname(host)
        else:
            print(burner.read_hostname())

    elif arguments["ssh"]:
        key = arguments["PUBLICKEY"]
        if key is None:
            key = os.path.expanduser("~") + "/.ssh/id_rsa.pub"
        print("set host to", key)
        burner = piburner()
        burner.activate_ssh(key)

    elif arguments["info"]:
        burner = piburner()
        burner.info()


if __name__ == '__main__':
    arguments = docopt(__doc__, version=VERSION)
    print('test')
    # if debug:
    #   print(arguments) # just for debugging
    analyse()
